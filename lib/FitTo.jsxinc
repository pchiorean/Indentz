/*
	Fit to... v4.0.0-beta
	Â© January 2021, Paul Chiorean
	Resizes the selected objects to the page/spread's size/margins/safe area/bleed.
	It's run internally by all the other FitTo scripts.

	SCOPE: 'page' | 'spread'
	TARGET: null | 'bleed' | 'margins' | 'safe area'
	FORCED_FIT: true | false
*/

const DEBUG = true;
const SNAP_PCT = 1; // Snap distance: percent of target
const HW_PCT = 10; // HW: percent of visible area

function main() {

if (!(doc = app.activeDocument)) exit();
var sel = doc.selection;
if (sel.length == 0 || (sel[0].constructor.name == "Guide")) exit();

var set_RO = doc.viewPreferences.rulerOrigin;
doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;
app.scriptPreferences.measurementUnit = MeasurementUnits.MILLIMETERS;
var obj, page, f, selBAK = [];
while (obj = sel.shift()) {
	if (page = obj.parentPage) {
		if ((f = Fit2Bounds(obj)) != undefined) { selBAK.push(f) } else { selBAK.push(obj) }
	} else if (FORCED_FIT) { // If forced fit, include objects on pasteboard
		var pages = app.activeWindow.activeSpread.pages;
		for (var i = 0; i < pages.length; i++) {
			if (obj.geometricBounds[3] <= pages[0].bounds[3]) { page = pages[0]; break }
			if (obj.geometricBounds[1] >= pages[i].bounds[1] &&
				obj.geometricBounds[3] <= pages[i].bounds[3]) { page = pages[i]; break }
			if (obj.geometricBounds[1] >= pages[-1].bounds[1]) { page = pages[-1]; break }
		}
		if ((f = Fit2Bounds(obj)) != undefined) { selBAK.push(f) } else { selBAK.push(obj) }
	}
}
if (selBAK.length > 0) app.select(selBAK);
doc.viewPreferences.rulerOrigin = set_RO;

function Fit2Bounds(obj) {
	var pg = Bounds(page, SCOPE, null);
	var tg = Bounds(page, SCOPE, TARGET);
	var mg = Bounds(page, SCOPE, "margins");
	var sa = Bounds(page, SCOPE, "safe area");
	var objG = obj.geometricBounds;
	var objV = obj.visibleBounds;
	var objRA = obj.absoluteRotationAngle;
	// Snap zones: target and safe area
	var snapDist = (sa != undefined) ? // Safe area takes precedence
		Math.min(sa[2] - sa[0], sa[3] - sa[1]) * SNAP_PCT / 100 :
		(TARGET == "margins" ?
			Math.min(tg[2] - tg[0], tg[3] - tg[1]) * SNAP_PCT / 100 :
			Math.min(pg[2] - pg[0], pg[3] - pg[1]) * SNAP_PCT / 100);
	var tgSZ = (TARGET == "margins") ?
		[ tg[0] + snapDist, tg[1] + snapDist, tg[2] - snapDist, tg[3] - snapDist ] :
		[ pg[0] + snapDist, pg[1] + snapDist, pg[2] - snapDist, pg[3] - snapDist ];
	var saSZ = (sa != undefined) ?
		[ sa[0] + snapDist, sa[1] + snapDist, sa[2] - snapDist, sa[3] - snapDist ] :
		[ pg[0] + snapDist, pg[1] + snapDist, pg[2] - snapDist, pg[3] - snapDist ];

	// Fit: HW (dimensions are predefined, so skip the nasty stuff)
	if (obj.label == "HW") {
		var hwRef = (TARGET == "margins") ? tg : pg;
		if (sa != undefined) { hwRef = sa; if (TARGET == "margins") tg = sa }
		if (obj.constructor.name == "TextFrame") { // Adjust inset for text frames
			obj.textFramePreferences.insetSpacing = [ 0, hwRef[1] - tg[1], tg[2] - hwRef[2], tg[3] - hwRef[3] ];
		}
		obj.geometricBounds = [ hwRef[2] - (hwRef[2] - hwRef[0]) * Number(HW_PCT) / 100, tg[1], tg[2], tg[3] ];
		return obj;
	}

	// Compute new bounds
	if (!FORCED_FIT) {
		// Check which obj's sides are in the safe area's snap zone
		var flg_sa = [
			(objG[0] <= saSZ[0] && objG[2] >= saSZ[0] && objG[1] <= saSZ[3] && objG[3] >= saSZ[1]),
			(objG[1] <= saSZ[1] && objG[3] >= saSZ[1] && objG[0] <= saSZ[2] && objG[2] >= saSZ[0]),
			(objG[2] >= saSZ[2] && objG[0] <= saSZ[2] && objG[1] <= saSZ[3] && objG[3] >= saSZ[1]),
			(objG[3] >= saSZ[3] && objG[1] <= saSZ[3] && objG[0] <= saSZ[2] && objG[2] >= saSZ[0])
		];
		// Check if obj is outside bounds | inside bounds but not in the target snap zone
		if (objV[2] <= tg[0] || objV[3] <= tg[1] || objV[0] >= tg[2] || objV[1] >= tg[3]) return;
		if (!(flg_sa[0] || flg_sa[1] || flg_sa[2] || flg_sa[3]) &&
			(objV[0] >= tgSZ[0] && objV[1] >= tgSZ[1] && objV[2] <= tgSZ[2] && objV[3] <= tgSZ[3])) return;
		// New target bounds --
		var fitR = [ // If larger, reduce to bounds
			objG[2] > tg[0] ? Math.max(objV[0], tg[0]) : objG[0],
			objG[3] > tg[1] ? Math.max(objV[1], tg[1]) : objG[1],
			objG[0] < tg[2] ? Math.min(objV[2], tg[2]) : objG[2],
			objG[1] < tg[3] ? Math.min(objV[3], tg[3]) : objG[3]
		];
		var fitE = [ // If smaller, expand to bounds if inside snap zones
			fitR[0] < tgSZ[0] ? tg[0] : (flg_sa[0] ? tg[0] : fitR[0]),
			fitR[1] < tgSZ[1] ? tg[1] : (flg_sa[1] ? tg[1] : fitR[1]),
			fitR[2] > tgSZ[2] ? tg[2] : (flg_sa[2] ? tg[2] : fitR[2]),
			fitR[3] > tgSZ[3] ? tg[3] : (flg_sa[3] ? tg[3] : fitR[3])
		];
		if (DEBUG) DBGFrames();
	}

	// Fit --
	// Already clipped
	if ((obj.name == "<clip frame>" || obj.name == "<auto clip frame>") && obj.pageItems[0].isValid) {
		obj.geometricBounds = FORCED_FIT ? tg : fitE; return obj;
	}
	// Simple rectangles and containers
	if (obj.constructor.name == "Rectangle" &&
		(obj.pageItems.length == 0 || obj.pageItems.length == 1) &&
		(obj.strokeWeight == 0 || obj.strokeAlignment == StrokeAlignment.INSIDE_ALIGNMENT) &&
		(objRA == 0 || Math.abs(objRA) == 90 || Math.abs(objRA) == 180)) {
			obj.geometricBounds = FORCED_FIT ? tg : fitE; return obj;
	}
	// Text frames
	if (obj.constructor.name == "TextFrame" &&
		(objRA == 0 || Math.abs(objRA) == 90 || Math.abs(objRA) == 180)) {
			obj.geometricBounds = FORCED_FIT ? tg : fitR; return obj;
	}
	// Orthogonal lines
	if (obj.constructor.name == "GraphicLine" &&
		(objG[0] == objG[2]) || (objG[1] == objG[3])) {
		// ***TODO***
		return obj;
	}
	// Groups
	if (obj.constructor.name == "Group") return Clip(obj, FORCED_FIT ? tg : fitR);
	// Other cases
	return Clip(obj, FORCED_FIT ? tg : fitE);

	function Clip(obj, fit) {
		if (objV[0] >= tg[0] && objV[1] >= tg[1] && objV[2] <= tg[2] && objV[3] <= tg[3]) return obj;
		var frame = doc.rectangles.add(
			obj.itemLayer, LocationOptions.AFTER, obj,
			{ name: "<clip frame>", label: obj.label,
			fillColor: "None", strokeColor: "None",
			geometricBounds: fit });
		frame.sendToBack(obj);
		app.select(obj); app.cut(); app.select(frame); app.pasteInto();
		return frame;
	}

	function DBGFrames() {
		var layer = doc.layers.item(".debug");
		if (!layer.isValid) {
			doc.layers.add({ name: ".debug", layerColor: UIColors.BLACK })
			.move(LocationOptions.AT_END);
		} else {
			var item, items = page.parent.pageItems.everyItem().getElements();
			while (item = items.shift()) if (item.label == "debug") item.remove();
		}
		// dbgFrame("Black", false, fitE);
		// dbgFrame("Black", false, fitR);
		debugFrame("Black", false, tg);
		debugFrame("Cyan", true, tgSZ);
		debugFrame("Magenta", true, saSZ);
		debugFrame("Cyan", false, Bounds(page, "page", "margins"));

		function debugFrame(color, /*bool*/SZ, bounds) {
			var frame = page.parent.rectangles.add(layer,
				{ label: "debug", geometricBounds: bounds, contentType: ContentType.UNASSIGNED,
				fillColor: "None", strokeColor: color, strokeWeight: SZ ? snapDist : "2 pt",
				strokeAlignment: SZ ? StrokeAlignment.OUTSIDE_ALIGNMENT : StrokeAlignment.INSIDE_ALIGNMENT,
				strokeType: SZ ? "$ID/Solid" : "$ID/Canned Dashed 3x2" });
			frame.transparencySettings.blendingSettings.opacity = SZ ? 25 : 100;
		}
	}
}

function Bounds(page, /*'page'|'spread'*/scope, /*null|'bleed'|'margins'|'safe area'*/target) {
	var fPg = page.parent.pages.firstItem();
	var lPg = page.parent.pages.lastItem();
	var bleed = {
		top: doc.documentPreferences.properties.documentBleedTopOffset,
		left: doc.documentPreferences.properties.documentBleedInsideOrLeftOffset,
		bottom: doc.documentPreferences.properties.documentBleedBottomOffset,
		right: doc.documentPreferences.properties.documentBleedOutsideOrRightOffset }
	var margins = {
		top: page.marginPreferences.top,
		left: page.marginPreferences.left,
		bottom: page.marginPreferences.bottom,
		right: page.marginPreferences.right }
	switch (scope) {
	case "page":
		switch (target) {
			case "bleed": return [
				page.bounds[0] - bleed.top,
				page.bounds[1] - (page == fPg ?
					(fPg.side == PageSideOptions.LEFT_HAND ? bleed.right : bleed.left) : 0),
				page.bounds[2] + bleed.bottom,
				page.bounds[3] + (fPg == lPg ?
					(fPg.side == PageSideOptions.LEFT_HAND ? bleed.left : bleed.right) :
					(page == lPg ? bleed.right : 0)) ];
			case "margins": return [
				page.bounds[0] + margins.top,
				page.side == PageSideOptions.LEFT_HAND ?
					page.bounds[1] + margins.right : page.bounds[1] + margins.left,
				page.bounds[2] - margins.bottom,
				page.side == PageSideOptions.LEFT_HAND ?
					page.bounds[3] - margins.left : page.bounds[3] - margins.right ];
			case "safe area":
				var s = [], frame, frames = page.rectangles.everyItem().getElements();
				while (frame = frames.shift()) if (frame.label == "safe area") s.push(frame);
				if (s.length == 0) return;
				var sa = s[0].geometricBounds;
				for (var i = 1; i < s.length; i++) {
					sa[0] = Math.min(s[i].geometricBounds[0], sa[0]);
					sa[1] = Math.min(s[i].geometricBounds[1], sa[1]);
					sa[2] = Math.max(s[i].geometricBounds[2], sa[2]);
					sa[3] = Math.max(s[i].geometricBounds[3], sa[3]);
				}
				return [
					Math.max(sa[0], page.bounds[0]),
					Math.max(sa[1], page.bounds[1]),
					Math.min(sa[2], page.bounds[2]),
					Math.min(sa[3], page.bounds[3])
				];
			default: return page.bounds;
		}
	case "spread":
		switch (target) {
			case "bleed": return [
				fPg.bounds[0] - bleed.top,
				fPg.bounds[1] - (fPg.side == PageSideOptions.LEFT_HAND ? bleed.right : bleed.left),
				lPg.bounds[2] + bleed.bottom,
				lPg.bounds[3] + (fPg == lPg ?
					(fPg.side == PageSideOptions.LEFT_HAND ? bleed.left : bleed.right) : bleed.right)
				];
			case "margins":
				var fm, lm, p = page.parent.pages;
				for (var i = 0; i < p.length; i++) { var m = p[i].marginPreferences;
					if (m.top + m.left + m.bottom + m.right > 0) { fm = p[i]; break } }
				for (var i = p.length - 1; i >= 0 ; i--) { var m = p[i].marginPreferences;
					if (m.top + m.left + m.bottom + m.right > 0) { lm = p[i]; break } }
				if (!fm && !lm) return [ fPg.bounds[0], fPg.bounds[1], lPg.bounds[2], lPg.bounds[3] ];
				else return [
					Math.min(fm.bounds[0] + fm.marginPreferences.top, lm.bounds[0] + lm.marginPreferences.top),
					fm.bounds[1] + (fm.side == PageSideOptions.LEFT_HAND ?
						fm.marginPreferences.right : fm.marginPreferences.left),
					Math.max(lm.bounds[2] - lm.marginPreferences.bottom, fm.bounds[2] - fm.marginPreferences.bottom),
					lm.bounds[3] - (fm == lm ?
						(fm.side == PageSideOptions.LEFT_HAND ?
							fm.marginPreferences.left : fm.marginPreferences.right) :
							lm.marginPreferences.right)
				];
			case "safe area":
				var s = [], frame, frames = page.parent.rectangles.everyItem().getElements();
				while (frame = frames.shift()) if (frame.label == "safe area") s.push(frame);
				if (s.length == 0) return;
				var sa = s[0].geometricBounds;
				for (var i = 1; i < s.length; i++) {
					sa[0] = Math.min(s[i].geometricBounds[0], sa[0]);
					sa[1] = Math.min(s[i].geometricBounds[1], sa[1]);
					sa[2] = Math.max(s[i].geometricBounds[2], sa[2]);
					sa[3] = Math.max(s[i].geometricBounds[3], sa[3]);
				}
				return sa;
			default: return [ fPg.bounds[0], fPg.bounds[1], lPg.bounds[2], lPg.bounds[3] ];
		}
	}
}

} // End main()
