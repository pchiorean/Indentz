/*
	FitTo v5.5.6 (2021-10-25)
	(c) 2020-2021 Paul Chiorean (jpeg@basement.ro)

	Reframes the selected objects to the page/spread's size/margins/visible area/bleed. If an object is larger
	than the target, it will be reduced; if it is smaller but inside a 1% 'snap' area, it will be enlarged.
	Rectangular frames are simply reframed; rotated objects, ovals, groups, etc. are inserted in a clipping
	frame that is reframed.

	It's called internally by the other 'fitTo' scripts, with three arguments:

	Parameters │ Type      │ Default │ Description
	───────────┼───────────┼─────────┼────────────────────────────────────────────────────────────────────────
	[scope]    │ `string`  │ `page`  │ `page` or `spread`.
	[target]   │ `string`  │ `size`  │ `size`, `margins`, `visible` or `bleed`.
	[forced]   │ `boolean` │ `false` │ When `true` it just reframes the object without any checks. (Optional.)

	Note: 'Visible area' is an area marked by one or more frames named `<visible area>` or labeled `visible area`.

	Examples:

	fitTo('page', 'bleed'); // Fits the selected objects to the page bleed

	app.doScript(
	    fitTo, ScriptLanguage.JAVASCRIPT,
	    [ 'page', 'bleed' ],
	    UndoModes.ENTIRE_SCRIPT, 'Fit to page bleed'
	);

	Released under MIT License:
	https://choosealicense.com/licenses/mit/

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

/* eslint-disable no-mixed-spaces-and-tabs */

// @include 'GetBounds.jsxinc';

function fitTo(args) {
	if (!(doc = app.activeDocument)) exit();
	var selection = doc.selection;
	if (selection.length === 0 || (selection[0].constructor.name === 'Guide')) exit();

	var SCOPE    = args[0] || 'page';
	var TARGET   = args[1] || 'size';
	var FORCED   = args[2] || false;
	var SNAP_PCT = 1;  // Snap distance in percent of target
	var HW_PCT   = 10; // HW size in percent of visible area
	var DEBUG    = false;
	var clippingFrameRE = /^<(auto )?clip(ping)? frame>$/i;
	var item, page, pages, fitted;
	var newSelection = [];
	var oldRO = doc.viewPreferences.rulerOrigin;
	doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;
	app.scriptPreferences.measurementUnit = MeasurementUnits.MILLIMETERS;

	while ((item = selection.shift())) {
		if (!Object.prototype.hasOwnProperty.call(item, 'parentPage')) continue;
		if (item.parent.constructor.name !== 'Spread') continue;
		if ((page = item.parentPage)) { // Skip objects on pasteboard
			if ((fitted = fit2Bounds(item))) newSelection.push(fitted); else newSelection.push(item);
		} else if (FORCED) { // FORCED includes objects on pasteboard
			pages = app.activeWindow.activeSpread.pages;
			for (var i = 0, n = pages.length; i < n; i++) {
				if (item.geometricBounds[3] <= pages[0].bounds[3]) { page = pages[0]; break; }
				if (item.geometricBounds[1] >= pages[i].bounds[1] &&
				    item.geometricBounds[3] <= pages[i].bounds[3]) { page = pages[i]; break; }
				if (item.geometricBounds[1] >= pages[-1].bounds[1]) { page = pages[-1]; break; }
			}
			if ((fitted = fit2Bounds(item))) newSelection.push(fitted); else newSelection.push(item);
		}
	}
	if (newSelection.length > 0) app.select(newSelection);
	doc.viewPreferences.rulerOrigin = oldRO;

	function fit2Bounds(obj) {
		var B = getBounds(page);
		var b = {
			size:   B[SCOPE].size,
			target: B[SCOPE][TARGET],
			vis:    B[SCOPE].visible
		};
		if (!b.target) return obj;
		if (FORCED && obj.constructor.name !== 'GraphicLine') { obj.geometricBounds = b.target; return obj; }

		// Initialization
		var o = {
			geo:   obj.geometricBounds,
			vis:   obj.visibleBounds,
			child: (obj.pageItems.length === 1 && obj.fillColor.name === 'None') ?
			       obj.pageItems[0].visibleBounds : undefined,
			hit:   []
		};
		var isStraight = Boolean(
			obj.absoluteRotationAngle === 0 ||
			Math.abs(obj.absoluteRotationAngle) === 90 ||
			Math.abs(obj.absoluteRotationAngle) === 180
		);
		var isNotSkewed = Boolean(obj.absoluteShearAngle === 0);
		// Snap zones: target and visible area; visible area takes precedence
		var snapDist = b.vis ?
			Math.min(b.vis[2] - b.vis[0], b.vis[3] - b.vis[1]) * SNAP_PCT / 100 :
			(TARGET === 'margins' ?
				Math.min(b.target[2] - b.target[0], b.target[3] - b.target[1]) * SNAP_PCT / 100 :
				Math.min(b.size[2]   - b.size[0],   b.size[3]   - b.size[1])   * SNAP_PCT / 100);
		var snapZone = {
			target: (TARGET === 'margins') ?
				[ b.target[0] + snapDist, b.target[1] + snapDist,
				  b.target[2] - snapDist, b.target[3] - snapDist ] :
				[ b.size[0]   + snapDist, b.size[1]   + snapDist,
				  b.size[2]   - snapDist, b.size[3]   - snapDist ],
			vis: b.vis ?
				[ b.vis[0]  + snapDist, b.vis[1]  + snapDist,
				  b.vis[2]  - snapDist, b.vis[3]  - snapDist ] :
				[ b.size[0] + snapDist, b.size[1] + snapDist,
				  b.size[2] - snapDist, b.size[3] - snapDist ]
		};

		// HW has predefined dimensions, so skip the nasty stuff
		if (/hw/gi.test(obj.label) &&
			(obj.constructor.name === 'TextFrame' || obj.constructor.name === 'Rectangle')) {
			var hwRef = (TARGET === 'margins') ? b.target : b.size;
			if (b.vis) {
				hwRef = b.vis;
				if (TARGET === 'margins') b.target = b.vis;
			}
			obj.geometricBounds = [
				hwRef[2] - (hwRef[2] - hwRef[0]) * Number(HW_PCT) / 100,
				b.target[1], b.target[2], b.target[3]
			];
			// Fix inset for text frames
			if (obj.constructor.name === 'TextFrame') {
				obj.textFramePreferences.insetSpacing = [
					0, hwRef[1] - b.target[1],
					b.target[2] - hwRef[2], b.target[3] - hwRef[3]
				];
			}
			return obj;
		}

		// Compute new bounds
		// -- Cancel if obj is outside bounds
		if (o.vis[2] <= b.target[0] || o.vis[3] <= b.target[1] ||
			o.vis[0] >= b.target[2] || o.vis[1] >= b.target[3]) return undefined;
		// -- Cancel if obj is inside bounds, but not into target snap zone
		o.hit = [ // Remember obj's sides that touch visible area snap zone
			(o.geo[0] <= snapZone.vis[0] && o.geo[2] >= snapZone.vis[0] &&
			 o.geo[1] <= snapZone.vis[3] && o.geo[3] >= snapZone.vis[1]),
			(o.geo[1] <= snapZone.vis[1] && o.geo[3] >= snapZone.vis[1] &&
			 o.geo[0] <= snapZone.vis[2] && o.geo[2] >= snapZone.vis[0]),
			(o.geo[2] >= snapZone.vis[2] && o.geo[0] <= snapZone.vis[2] &&
			 o.geo[1] <= snapZone.vis[3] && o.geo[3] >= snapZone.vis[1]),
			(o.geo[3] >= snapZone.vis[3] && o.geo[1] <= snapZone.vis[3] &&
			 o.geo[0] <= snapZone.vis[2] && o.geo[2] >= snapZone.vis[0])
		];
		if (!(o.hit[0] || o.hit[1] || o.hit[2] || o.hit[3]) &&
			(o.vis[0] >= snapZone.target[0] && o.vis[1] >= snapZone.target[1] &&
			 o.vis[2] <= snapZone.target[2] && o.vis[3] <= snapZone.target[3])) return undefined;
		// -- Adjusted bounds: if larger than target, reduce
		b.reduce = [
			o.geo[2] > b.target[0] ? Math.max(o.vis[0], b.target[0]) : o.geo[0],
			o.geo[3] > b.target[1] ? Math.max(o.vis[1], b.target[1]) : o.geo[1],
			o.geo[0] < b.target[2] ? Math.min(o.vis[2], b.target[2]) : o.geo[2],
			o.geo[1] < b.target[3] ? Math.min(o.vis[3], b.target[3]) : o.geo[3]
		];
		// -- If smaller than target & into snap zone, expand
		b.expand = [
			b.reduce[0] < snapZone.target[0] ? b.target[0] : (o.hit[0] ? b.target[0] : b.reduce[0]),
			b.reduce[1] < snapZone.target[1] ? b.target[1] : (o.hit[1] ? b.target[1] : b.reduce[1]),
			b.reduce[2] > snapZone.target[2] ? b.target[2] : (o.hit[2] ? b.target[2] : b.reduce[2]),
			b.reduce[3] > snapZone.target[3] ? b.target[3] : (o.hit[3] ? b.target[3] : b.reduce[3])
		];
		// -- but not past content's bounds
		if (o.child) {
			b.expand = [
				o.child[0] > b.target[0] ? Math.max(o.child[0], b.expand[0]) : b.expand[0],
				o.child[1] > b.target[1] ? Math.max(o.child[1], b.expand[1]) : b.expand[1],
				o.child[2] < b.target[2] ? Math.min(o.child[2], b.expand[2]) : b.expand[2],
				o.child[3] < b.target[3] ? Math.min(o.child[3], b.expand[3]) : b.expand[3]
			];
		}
		if (DEBUG) showDebugFrames();

		// Fit obj to new bounds
		// -- Already clipped
		if (clippingFrameRE.test(obj.name) && obj.pageItems[0].isValid) {
			obj.geometricBounds = b.expand;
			return obj;
		}
		// -- Simple rectangles and containers
		if (obj.constructor.name === 'Rectangle' && isStraight && isNotSkewed &&
			(obj.pageItems.length === 0 || obj.pageItems.length === 1) &&
			// (obj.strokeWeight === 0 || obj.strokeAlignment === StrokeAlignment.INSIDE_ALIGNMENT) &&
			obj.strokeWeight < 1) {
			obj.geometricBounds = b.expand;
			return obj;
		}
		// -- Text frames
		if (obj.constructor.name === 'TextFrame' && isStraight && isNotSkewed) {
			obj.geometricBounds = b.expand;
			return obj;
		}
		// -- Orthogonal lines
		var isOrthoLine = (obj.constructor.name === 'GraphicLine' &&
			obj.paths[0].entirePath.length === 2 &&
			(obj.paths[0].entirePath[0].length === 2 || obj.paths[0].entirePath[1].length === 2));
		if (isOrthoLine && o.geo[0] === o.geo[2]) { // horizontal
			obj.paths[0].entirePath = [
				[ FORCED ? b.target[1] : b.expand[1], obj.paths[0].entirePath[0][1] ],
				[ FORCED ? b.target[3] : b.expand[3], obj.paths[0].entirePath[1][1] ]
			];
			return obj;
		}
		if (isOrthoLine && o.geo[1] === o.geo[3]) { // vertical
			obj.paths[0].entirePath = [
				[ obj.paths[0].entirePath[0][0], FORCED ? b.target[0] : b.expand[0] ],
				[ obj.paths[0].entirePath[1][0], FORCED ? b.target[2] : b.expand[2] ]
			];
			return obj;
		}
		// -- Groups
		if (obj.constructor.name === 'Group') return clipObject(b.reduce);
		// -- Other cases
		return clipObject(b.expand);

		function clipObject(fitMode) {
			if (o.vis[0] >= b.target[0] && o.vis[1] >= b.target[1] &&
				o.vis[2] <= b.target[2] && o.vis[3] <= b.target[3]) return obj;
			var frame = doc.rectangles.add(
				obj.itemLayer,
				LocationOptions.AFTER, obj,
				{
					name: '<clipping frame>',
					label: obj.label,
					fillColor: 'None',
					strokeColor: 'None',
					geometricBounds: fitMode
				}
			);
			frame.sendToBack(obj);
			app.select(obj); app.cut();
			app.select(frame); app.pasteInto();
			return frame;
		}

		function showDebugFrames() {
			var layer = doc.layers.item('.debug');
			if (layer.isValid) { layer.locked = false; layer.remove(); }
			layer = doc.layers.add({ name: '.debug', layerColor: UIColors.BLACK }).move(LocationOptions.AT_END);
			// createDebugFrame('Black',   false, b.expand,        'b.expand');
			// createDebugFrame('Black',   false, b.reduce,        'b.reduce');
			if (o.child) createDebugFrame('Yellow', false, o.child, 'o.child');
			createDebugFrame('Black',   false, b.target,        'b.target');
			createDebugFrame('Cyan',    true,  snapZone.target, 'snapZone.target');
			createDebugFrame('Magenta', true,  snapZone.vis,    'snapZone.vis');
			createDebugFrame('Cyan',    false, B.page.margins,  'B.page.margins');
			layer.locked = true;

			function createDebugFrame(color, /*bool*/isZone, bounds, label) {
				page.parent.rectangles.add(
					layer,
					LocationOptions.AT_END,
					{
						name: '<debug frame>',
						label: label || '',
						geometricBounds: bounds,
						contentType: ContentType.UNASSIGNED,
						fillColor: 'None',
						strokeColor: color,
						strokeWeight: isZone ? snapDist : '1.5 pt',
						strokeAlignment: isZone ? StrokeAlignment.OUTSIDE_ALIGNMENT : StrokeAlignment.INSIDE_ALIGNMENT,
						strokeType: isZone ? '$ID/Solid' : '$ID/Canned Dashed 3x2',
						transparencySettings: { blendingSettings: { opacity: isZone ? 25 : 100 }}
					}
				);
			}
		}
	}
}
