/*
	Fit to... v4.0.0
	Â© February 2021, Paul Chiorean
	Resizes the selected objects to the page/spread's size/margins/safe area/bleed.

	It's called internally by all the other FitTo scripts; arguments are:
	1. SCOPE: 'page' | 'spread' (default 'page')
	2. TARGET: 'size' | 'margins' | 'safearea' | 'bleed' (default 'size')
	3. FORCED_FIT: true | false (default 'false')
*/

// @include "bounds.jsxinc";

const DEBUG = false;
const SNAP_PCT = 1; // Snap distance: percent of target
const HW_PCT = 10; // HW: percent of visible area

function FitTo(args) {

if (!(doc = app.activeDocument)) exit();
var sel = doc.selection;
if (sel.length == 0 || (sel[0].constructor.name == "Guide")) exit();

const SCOPE = args[0] || "page";
const TARGET = args[1] || "size";
const FORCED_FIT = args[2] || false;

var set_RO = doc.viewPreferences.rulerOrigin;
doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;
app.scriptPreferences.measurementUnit = MeasurementUnits.MILLIMETERS;
var obj, page, f, selBAK = [];
while (obj = sel.shift()) { // Skip objects on pasteboard
	if (page = obj.parentPage) {
		if ((f = Fit2Bounds(obj)) != undefined) { selBAK.push(f) } else { selBAK.push(obj) }
	} else if (FORCED_FIT) { // If forced fit, include objects on pasteboard
		var pages = app.activeWindow.activeSpread.pages;
		for (var i = 0; i < pages.length; i++) {
			if (obj.geometricBounds[3] <= pages[0].bounds[3]) { page = pages[0]; break }
			if (obj.geometricBounds[1] >= pages[i].bounds[1] &&
				obj.geometricBounds[3] <= pages[i].bounds[3]) { page = pages[i]; break }
			if (obj.geometricBounds[1] >= pages[-1].bounds[1]) { page = pages[-1]; break }
		}
		if ((f = Fit2Bounds(obj)) != undefined) { selBAK.push(f) } else { selBAK.push(obj) }
	}
}
if (selBAK.length > 0) app.select(selBAK);
doc.viewPreferences.rulerOrigin = set_RO;

function Fit2Bounds(obj) {
	var bounds = Bounds(page);
	var pg = bounds[SCOPE].size;
	var tg = bounds[SCOPE][TARGET]; if (tg == undefined) return obj;
	var mg = bounds[SCOPE]["margins"];
	var sa = bounds[SCOPE]["safearea"];
	var objG = obj.geometricBounds;
	var objV = obj.visibleBounds;
	var objRA = obj.absoluteRotationAngle;
	// Snap zones: target and safe area
	var snapDist = (sa != undefined) ? // Safe area takes precedence
		Math.min(sa[2] - sa[0], sa[3] - sa[1]) * SNAP_PCT / 100 :
		(TARGET == "margins" ?
			Math.min(tg[2] - tg[0], tg[3] - tg[1]) * SNAP_PCT / 100 :
			Math.min(pg[2] - pg[0], pg[3] - pg[1]) * SNAP_PCT / 100);
	var tgSZ = (TARGET == "margins") ?
		[ tg[0] + snapDist, tg[1] + snapDist, tg[2] - snapDist, tg[3] - snapDist ] :
		[ pg[0] + snapDist, pg[1] + snapDist, pg[2] - snapDist, pg[3] - snapDist ];
	var saSZ = (sa != undefined) ?
		[ sa[0] + snapDist, sa[1] + snapDist, sa[2] - snapDist, sa[3] - snapDist ] :
		[ pg[0] + snapDist, pg[1] + snapDist, pg[2] - snapDist, pg[3] - snapDist ];

	// Fit: HW (dimensions are predefined, so skip the nasty stuff)
	if (obj.label == "HW") {
		var hwRef = (TARGET == "margins") ? tg : pg;
		if (sa != undefined) { hwRef = sa; if (TARGET == "margins") tg = sa }
		if (obj.constructor.name == "TextFrame") { // Adjust inset for text frames
			obj.textFramePreferences.insetSpacing = [ 0, hwRef[1] - tg[1], tg[2] - hwRef[2], tg[3] - hwRef[3] ];
		}
		obj.geometricBounds = [ hwRef[2] - (hwRef[2] - hwRef[0]) * Number(HW_PCT) / 100, tg[1], tg[2], tg[3] ];
		return obj;
	}

	// Compute new bounds
	if (!FORCED_FIT) {
		// Check which obj's sides are in the safe area's snap zone
		var flgSA = [
			(objG[0] <= saSZ[0] && objG[2] >= saSZ[0] && objG[1] <= saSZ[3] && objG[3] >= saSZ[1]),
			(objG[1] <= saSZ[1] && objG[3] >= saSZ[1] && objG[0] <= saSZ[2] && objG[2] >= saSZ[0]),
			(objG[2] >= saSZ[2] && objG[0] <= saSZ[2] && objG[1] <= saSZ[3] && objG[3] >= saSZ[1]),
			(objG[3] >= saSZ[3] && objG[1] <= saSZ[3] && objG[0] <= saSZ[2] && objG[2] >= saSZ[0])
		];
		// Check if obj is outside bounds | inside bounds, but outside target snap zone
		if (objV[2] <= tg[0] || objV[3] <= tg[1] || objV[0] >= tg[2] || objV[1] >= tg[3]) return;
		if (!(flgSA[0] || flgSA[1] || flgSA[2] || flgSA[3]) &&
			(objV[0] >= tgSZ[0] && objV[1] >= tgSZ[1] && objV[2] <= tgSZ[2] && objV[3] <= tgSZ[3])) return;
		// New target bounds --
		// -- If larger than target, reduce
		var fitR = [
			objG[2] > tg[0] ? Math.max(objV[0], tg[0]) : objG[0],
			objG[3] > tg[1] ? Math.max(objV[1], tg[1]) : objG[1],
			objG[0] < tg[2] ? Math.min(objV[2], tg[2]) : objG[2],
			objG[1] < tg[3] ? Math.min(objV[3], tg[3]) : objG[3]
		];
		// -- If smaller than target & into snap zone, expand
		var fitE = [
			fitR[0] < tgSZ[0] ? tg[0] : (flgSA[0] ? tg[0] : fitR[0]),
			fitR[1] < tgSZ[1] ? tg[1] : (flgSA[1] ? tg[1] : fitR[1]),
			fitR[2] > tgSZ[2] ? tg[2] : (flgSA[2] ? tg[2] : fitR[2]),
			fitR[3] > tgSZ[3] ? tg[3] : (flgSA[3] ? tg[3] : fitR[3])
		];
		// -- But don't expand past child's bounds
		if (obj.pageItems.length == 1 && obj.fillColor.name == "None") {
			var objC = obj.pageItems[0].visibleBounds;
			fitE = [
				objC[0] > tg[0] ? objC[0] : fitE[0],
				objC[1] > tg[1] ? objC[1] : fitE[1],
				objC[2] < tg[2] ? objC[2] : fitE[2],
				objC[3] < tg[3] ? objC[3] : fitE[3]
			];
		}
		if (DEBUG) DBGFrames();
	}

	// Fit --
	// -- Already clipped
	if ((obj.name == "<clip frame>" || obj.name == "<auto clip frame>") && obj.pageItems[0].isValid) {
		obj.geometricBounds = FORCED_FIT ? tg : fitE;
		return obj;
	}
	// -- Simple rectangles and containers
	if (obj.constructor.name == "Rectangle" &&
		(obj.pageItems.length == 0 || obj.pageItems.length == 1) &&
		(obj.strokeWeight == 0 || obj.strokeAlignment == StrokeAlignment.INSIDE_ALIGNMENT) &&
		(objRA == 0 || Math.abs(objRA) == 90 || Math.abs(objRA) == 180)) {
			obj.geometricBounds = FORCED_FIT ? tg : fitE;
			return obj;
	}
	// -- Text frames
	if (obj.constructor.name == "TextFrame" &&
		(objRA == 0 || Math.abs(objRA) == 90 || Math.abs(objRA) == 180)) {
			obj.geometricBounds = FORCED_FIT ? tg : fitR;
			return obj;
	}
	// -- Orthogonal lines: horizontal
	if (obj.constructor.name == "GraphicLine" && obj.paths[0].entirePath.length == 2 && objG[0] == objG[2]) {
		obj.paths[0].entirePath = [
			[ fitE[1], obj.paths[0].entirePath[0][1] ],
			[ fitE[3], obj.paths[0].entirePath[1][1] ]
		];
		return obj;
	}
	// -- Orthogonal lines: vertical
	if (obj.constructor.name == "GraphicLine" && obj.paths[0].entirePath.length == 2 && objG[1] == objG[3]) {
		obj.paths[0].entirePath = [
			[ obj.paths[0].entirePath[0][0], fitE[0] ],
			[ obj.paths[0].entirePath[1][0], fitE[2] ]
		];
		return obj;
	}
	// -- Groups
	if (obj.constructor.name == "Group") return Clip(obj, FORCED_FIT ? tg : fitR);
	// -- Other cases
	return Clip(obj, FORCED_FIT ? tg : fitE);

	function Clip(obj, fit) {
		if (objV[0] >= tg[0] && objV[1] >= tg[1] && objV[2] <= tg[2] && objV[3] <= tg[3]) return obj;
		var frame = doc.rectangles.add(
			obj.itemLayer, LocationOptions.AFTER, obj,
			{ name: "<clip frame>", label: obj.label,
			fillColor: "None", strokeColor: "None",
			geometricBounds: fit });
		frame.sendToBack(obj);
		app.select(obj); app.cut(); app.select(frame); app.pasteInto();
		return frame;
	}

	function DBGFrames() {
		var layer = doc.layers.item(".debug");
		if (!layer.isValid) {
			doc.layers.add({ name: ".debug", layerColor: UIColors.BLACK })
			.move(LocationOptions.AT_END);
		} else {
			var item, items = page.parent.pageItems.everyItem().getElements();
			while (item = items.shift()) if (item.label == "debug") item.remove();
		}
		// debugFrame("Black", false, fitE);
		// debugFrame("Black", false, fitR);
		objC && debugFrame("Yellow", false, objC);
		debugFrame("Black", false, tg);
		debugFrame("Cyan", true, tgSZ);
		debugFrame("Magenta", true, saSZ);
		debugFrame("Cyan", false, bounds["page"]["margins"]);

		function debugFrame(color, /*bool*/SZ, bounds) {
			var frame = page.parent.rectangles.add(layer,
				{ label: "debug", geometricBounds: bounds, contentType: ContentType.UNASSIGNED,
				fillColor: "None", strokeColor: color, strokeWeight: SZ ? snapDist : "2 pt",
				strokeAlignment: SZ ? StrokeAlignment.OUTSIDE_ALIGNMENT : StrokeAlignment.INSIDE_ALIGNMENT,
				strokeType: SZ ? "$ID/Solid" : "$ID/Canned Dashed 3x2" });
			frame.transparencySettings.blendingSettings.opacity = SZ ? 25 : 100;
		}
	}
}

} // End main
