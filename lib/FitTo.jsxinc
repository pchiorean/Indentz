/*
	FitTo v5.5.7 (2021-11-02)
	(c) 2020-2021 Paul Chiorean (jpeg@basement.ro)

	Reframes the selected objects to the page/spread's size/margins/visible area/bleed. If an object is larger
	than the target, it will be reduced; if it is smaller but inside a 1% 'snap' area, it will be enlarged.
	Rectangular frames are simply reframed; rotated objects, ovals, groups, etc. are inserted in a clipping
	frame that is reframed.

	It's called internally by the other 'fitTo' scripts, with three arguments:

	Parameters │ Type      │ Default │ Description
	───────────┼───────────┼─────────┼────────────────────────────────────────────────────────────────────────
	[scope]    │ `string`  │ `page`  │ `page` or `spread`.
	[target]   │ `string`  │ `size`  │ `size`, `margins`, `visible` or `bleed`.
	[forced]   │ `boolean` │ `false` │ When `true` it just reframes the object without any checks. (Optional.)

	Note: 'Visible area' is an area marked by one or more frames named `<visible area>` or labeled `visible area`.

	Examples:

	fitTo('page', 'bleed'); // Fits the selected objects to the page bleed

	app.doScript(
	    fitTo, ScriptLanguage.JAVASCRIPT,
	    [ 'page', 'bleed' ],
	    UndoModes.ENTIRE_SCRIPT, 'Fit to page bleed'
	);

	Released under MIT License:
	https://choosealicense.com/licenses/mit/

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

/* eslint-disable no-mixed-spaces-and-tabs */

// @include 'GetBounds.jsxinc';

function fitTo(args) {
	if (!(doc = app.activeDocument)) exit();
	var selection = doc.selection;
	if (selection.length === 0 || (selection[0].constructor.name === 'Guide')) exit();

	var SCOPE  = args[0] || 'page';
	var TARGET = args[1] || 'size';
	var FORCED = args[2] || false;
	var SNAP_PCT = 1;  // Snap distance in percent of target
	var HW_PCT = 10; // HW size in percent of visible area
	var DEBUG = false;
	var clippingFrameRE = /^<(auto )?clip(ping)? frame>$/i;
	var item, page, pages, fitted;
	var newSelection = [];
	var oldRO = doc.viewPreferences.rulerOrigin;
	doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;
	app.scriptPreferences.measurementUnit = MeasurementUnits.MILLIMETERS;

	while ((item = selection.shift())) {
		if (!Object.prototype.hasOwnProperty.call(item, 'parentPage')) continue;
		if (item.parent.constructor.name !== 'Spread') continue;
		if ((page = item.parentPage)) { // Skip objects on pasteboard
			if ((fitted = fit2Bounds(item))) newSelection.push(fitted); else newSelection.push(item);
		} else if (FORCED) { // FORCED includes objects on pasteboard
			pages = app.activeWindow.activeSpread.pages;
			for (var i = 0, n = pages.length; i < n; i++) {
				if (item.geometricBounds[3] <= pages[0].bounds[3]) { page = pages[0]; break; }
				if (item.geometricBounds[1] >= pages[i].bounds[1] &&
				    item.geometricBounds[3] <= pages[i].bounds[3]) { page = pages[i]; break; }
				if (item.geometricBounds[1] >= pages[-1].bounds[1]) { page = pages[-1]; break; }
			}
			if ((fitted = fit2Bounds(item))) newSelection.push(fitted); else newSelection.push(item);
		}
	}
	if (newSelection.length > 0) app.select(newSelection);
	doc.viewPreferences.rulerOrigin = oldRO;

	function fit2Bounds(obj) {
		var B = getBounds(page);
		var b = {
			size: B[SCOPE].size,
			target: B[SCOPE][TARGET],
			vis: B[SCOPE].visible
		};
		if (!b.target) return obj;
		if (FORCED && obj.constructor.name !== 'GraphicLine') { obj.geometricBounds = b.target; return obj; }

		var o = {
			// Object bounds
			geo: obj.geometricBounds,
			vis: obj.visibleBounds,
			// Adjusted bounds
			clip: [],
			fit: [],
			// Containers: get the visible bounds of the child object, if any
			child: (obj.pageItems.length === 1 && obj.fillColor.name === 'None') ?
			       obj.pageItems[0].visibleBounds : undefined,
			// Track obj's sides that touch visible area snap zone - [ t, l, b, r], all booleans
			hit:   []
		};
		var isStraight = Boolean(
			obj.absoluteRotationAngle === 0 ||
			Math.abs(obj.absoluteRotationAngle) === 90 ||
			Math.abs(obj.absoluteRotationAngle) === 180
		);
		var isNotSkewed = Boolean(obj.absoluteShearAngle === 0);
		// Snap zones: target and visible area; visible area takes precedence
		var snapDist = b.vis ?
			Math.min(b.vis[2] - b.vis[0], b.vis[3] - b.vis[1]) * SNAP_PCT / 100 :
			(TARGET === 'margins' ?
				Math.min(b.target[2] - b.target[0], b.target[3] - b.target[1]) * SNAP_PCT / 100 :
				Math.min(b.size[2]   - b.size[0],   b.size[3]   - b.size[1])   * SNAP_PCT / 100);
		var snapZone = {
			target: (TARGET === 'margins') ?
				[ b.target[0] + snapDist, b.target[1] + snapDist,
				  b.target[2] - snapDist, b.target[3] - snapDist ] :
				[ b.size[0]   + snapDist, b.size[1]   + snapDist,
				  b.size[2]   - snapDist, b.size[3]   - snapDist ],
			vis: b.vis ?
				[ b.vis[0]  + snapDist, b.vis[1]  + snapDist,
				  b.vis[2]  - snapDist, b.vis[3]  - snapDist ] :
				[ b.size[0] + snapDist, b.size[1] + snapDist,
				  b.size[2] - snapDist, b.size[3] - snapDist ]
		};

		// Exception: HW has predefined dimensions, so skip the nasty stuff
		if (/hw/gi.test(obj.label) &&
			(obj.constructor.name === 'TextFrame' || obj.constructor.name === 'Rectangle')) {
			var hwRef = (TARGET === 'margins') ? b.target : b.size;
			if (b.vis) {
				hwRef = b.vis;
				if (TARGET === 'margins') b.target = b.vis;
			}
			obj.geometricBounds = [
				hwRef[2] - (hwRef[2] - hwRef[0]) * Number(HW_PCT) / 100,
				b.target[1], b.target[2], b.target[3]
			];
			// Fix inset for text frames
			if (obj.constructor.name === 'TextFrame') {
				obj.textFramePreferences.insetSpacing = [
					0, hwRef[1] - b.target[1],
					b.target[2] - hwRef[2], b.target[3] - hwRef[3]
				];
			}
			return obj;
		}

		// Compute new bounds

		// Cancel if obj is outside bounds
		if (o.vis[2] <= b.target[0] || o.vis[3] <= b.target[1] ||
			o.vis[0] >= b.target[2] || o.vis[1] >= b.target[3]) return undefined;

		// Cancel if obj is inside bounds, but not into target snap zone
		o.hit = [ // Flag sides that touch visible area snap zone
			(o.geo[0] <= snapZone.vis[0] && o.geo[2] >= snapZone.vis[0] &&
			 o.geo[1] <= snapZone.vis[3] && o.geo[3] >= snapZone.vis[1]),
			(o.geo[1] <= snapZone.vis[1] && o.geo[3] >= snapZone.vis[1] &&
			 o.geo[0] <= snapZone.vis[2] && o.geo[2] >= snapZone.vis[0]),
			(o.geo[2] >= snapZone.vis[2] && o.geo[0] <= snapZone.vis[2] &&
			 o.geo[1] <= snapZone.vis[3] && o.geo[3] >= snapZone.vis[1]),
			(o.geo[3] >= snapZone.vis[3] && o.geo[1] <= snapZone.vis[3] &&
			 o.geo[0] <= snapZone.vis[2] && o.geo[2] >= snapZone.vis[0])
		];
		if (!(o.hit[0] || o.hit[1] || o.hit[2] || o.hit[3]) &&
			(o.vis[0] >= snapZone.target[0] && o.vis[1] >= snapZone.target[1] &&
			 o.vis[2] <= snapZone.target[2] && o.vis[3] <= snapZone.target[3])) return undefined;

		// Adjust bounds: if larger, reduce to target
		o.clip = [
			o.geo[2] > b.target[0] ? Math.max(o.vis[0], b.target[0]) : o.geo[0],
			o.geo[3] > b.target[1] ? Math.max(o.vis[1], b.target[1]) : o.geo[1],
			o.geo[0] < b.target[2] ? Math.min(o.vis[2], b.target[2]) : o.geo[2],
			o.geo[1] < b.target[3] ? Math.min(o.vis[3], b.target[3]) : o.geo[3]
		];

		// If smaller but into snap zone, fit to target
		o.fit = [
			o.clip[0] < snapZone.target[0] ? b.target[0] : (o.hit[0] ? b.target[0] : o.clip[0]),
			o.clip[1] < snapZone.target[1] ? b.target[1] : (o.hit[1] ? b.target[1] : o.clip[1]),
			o.clip[2] > snapZone.target[2] ? b.target[2] : (o.hit[2] ? b.target[2] : o.clip[2]),
			o.clip[3] > snapZone.target[3] ? b.target[3] : (o.hit[3] ? b.target[3] : o.clip[3])
		];
		// But not past content's bounds
		if (o.child) {
			o.fit = [
				o.child[0] > b.target[0] ? Math.max(o.child[0], o.fit[0]) : o.fit[0],
				o.child[1] > b.target[1] ? Math.max(o.child[1], o.fit[1]) : o.fit[1],
				o.child[2] < b.target[2] ? Math.min(o.child[2], o.fit[2]) : o.fit[2],
				o.child[3] < b.target[3] ? Math.min(o.child[3], o.fit[3]) : o.fit[3]
			];
		}

		if (DEBUG) showDebugFrames();

		// Fit obj to the adjusted bounds

		// Is already clipped
		if (clippingFrameRE.test(obj.name) && obj.pageItems[0].isValid) {
			obj.geometricBounds = o.fit;
			return obj;
		}

		// Simple rectangles and containers
		if (obj.constructor.name === 'Rectangle' && isStraight && isNotSkewed &&
			(obj.pageItems.length === 0 || obj.pageItems.length === 1) &&
			// (obj.strokeWeight === 0 || obj.strokeAlignment === StrokeAlignment.INSIDE_ALIGNMENT) &&
			obj.strokeWeight < 1) {
			obj.geometricBounds = o.fit;
			return obj;
		}

		// Text frames
		if (obj.constructor.name === 'TextFrame' && isStraight && isNotSkewed) {
			obj.geometricBounds = o.fit;
			return obj;
		}

		// Orthogonal lines
		var isOrthoLine = (obj.constructor.name === 'GraphicLine' &&
			obj.paths[0].entirePath.length === 2 &&
			(obj.paths[0].entirePath[0].length === 2 || obj.paths[0].entirePath[1].length === 2));
		if (isOrthoLine && o.geo[0] === o.geo[2]) { // Horizontal line
			obj.paths[0].entirePath = [
				[ FORCED ? b.target[1] : o.fit[1], obj.paths[0].entirePath[0][1] ],
				[ FORCED ? b.target[3] : o.fit[3], obj.paths[0].entirePath[1][1] ]
			];
			return obj;
		}
		if (isOrthoLine && o.geo[1] === o.geo[3]) { // Vertical line
			obj.paths[0].entirePath = [
				[ obj.paths[0].entirePath[0][0], FORCED ? b.target[0] : o.fit[0] ],
				[ obj.paths[0].entirePath[1][0], FORCED ? b.target[2] : o.fit[2] ]
			];
			return obj;
		}

		// Groups
		if (obj.constructor.name === 'Group') return clipObject(o.clip); // Groups are always reduced

		// Clip other types
		return clipObject(o.fit);

		function clipObject(fitMode) {
			if (o.vis[0] >= b.target[0] && o.vis[1] >= b.target[1] &&
				o.vis[2] <= b.target[2] && o.vis[3] <= b.target[3]) return obj;
			var frame = doc.rectangles.add(
				obj.itemLayer,
				LocationOptions.AFTER, obj,
				{
					name: '<clipping frame>',
					label: obj.label,
					fillColor: 'None',
					strokeColor: 'None',
					geometricBounds: fitMode
				}
			);
			frame.sendToBack(obj);
			app.select(obj); app.cut();
			app.select(frame); app.pasteInto();
			return frame;
		}

		function showDebugFrames() {
			var layer = doc.layers.item('.debug');
			if (layer.isValid) { layer.locked = false; layer.remove(); }
			layer = doc.layers.add({ name: '.debug', layerColor: UIColors.BLACK }).move(LocationOptions.AT_END);
			// createDebugFrame('Black',   false, o.fit,           'o.fit');
			// createDebugFrame('Black',   false, o.clip,          'o.clip');
			if (o.child) createDebugFrame('Yellow', false, o.child, 'o.child');
			createDebugFrame('Black',   false, b.target,        'b.target');
			createDebugFrame('Cyan',    true,  snapZone.target, 'snapZone.target');
			createDebugFrame('Magenta', true,  snapZone.vis,    'snapZone.vis');
			createDebugFrame('Cyan',    false, B.page.margins,  'B.page.margins');
			layer.locked = true;

			function createDebugFrame(color, /*bool*/isZone, bounds, label) {
				page.parent.rectangles.add(
					layer,
					LocationOptions.AT_END,
					{
						name: '<debug frame>',
						label: label || '',
						geometricBounds: bounds,
						contentType: ContentType.UNASSIGNED,
						fillColor: 'None',
						strokeColor: color,
						strokeWeight: isZone ? snapDist : '1.5 pt',
						strokeAlignment: isZone ? StrokeAlignment.OUTSIDE_ALIGNMENT : StrokeAlignment.INSIDE_ALIGNMENT,
						strokeType: isZone ? '$ID/Solid' : '$ID/Canned Dashed 3x2',
						transparencySettings: { blendingSettings: { opacity: isZone ? 25 : 100 }}
					}
				);
			}
		}
	}
}
