/*
	Fit to... v4.0.0-beta
	Â© February 2021, Paul Chiorean
	Resizes the selected objects to the page/spread's size/margins/safe area/bleed.
	It's run internally by all the other FitTo scripts.

	SCOPE: 'page' | 'spread'
	TARGET: null | 'margins' | 'safe area' | 'bleed'
	FORCED_FIT: true | false
*/

// @include "bounds.jsxinc";

const DEBUG = false;
const SNAP_PCT = 1; // Snap distance: percent of target
const HW_PCT = 10; // HW: percent of visible area

function main() {

if (!(doc = app.activeDocument)) exit();
var sel = doc.selection;
if (sel.length == 0 || (sel[0].constructor.name == "Guide")) exit();

var set_RO = doc.viewPreferences.rulerOrigin;
doc.viewPreferences.rulerOrigin = RulerOrigin.SPREAD_ORIGIN;
app.scriptPreferences.measurementUnit = MeasurementUnits.MILLIMETERS;
var obj, page, f, selBAK = [];
while (obj = sel.shift()) {
	if (page = obj.parentPage) {
		if ((f = Fit2Bounds(obj)) != undefined) { selBAK.push(f) } else { selBAK.push(obj) }
	} else if (FORCED_FIT) { // If forced fit, include objects on pasteboard
		var pages = app.activeWindow.activeSpread.pages;
		for (var i = 0; i < pages.length; i++) {
			if (obj.geometricBounds[3] <= pages[0].bounds[3]) { page = pages[0]; break }
			if (obj.geometricBounds[1] >= pages[i].bounds[1] &&
				obj.geometricBounds[3] <= pages[i].bounds[3]) { page = pages[i]; break }
			if (obj.geometricBounds[1] >= pages[-1].bounds[1]) { page = pages[-1]; break }
		}
		if ((f = Fit2Bounds(obj)) != undefined) { selBAK.push(f) } else { selBAK.push(obj) }
	}
}
if (selBAK.length > 0) app.select(selBAK);
doc.viewPreferences.rulerOrigin = set_RO;

function Fit2Bounds(obj) {
	var pg = Bounds(page, SCOPE, null);
	var tg = Bounds(page, SCOPE, TARGET); if (tg == undefined) return obj;
	var mg = Bounds(page, SCOPE, "margins");
	var sa = Bounds(page, SCOPE, "safe area");
	var objG = obj.geometricBounds;
	var objV = obj.visibleBounds;
	var objRA = obj.absoluteRotationAngle;
	// Snap zones: target and safe area
	var snapDist = (sa != undefined) ? // Safe area takes precedence
		Math.min(sa[2] - sa[0], sa[3] - sa[1]) * SNAP_PCT / 100 :
		(TARGET == "margins" ?
			Math.min(tg[2] - tg[0], tg[3] - tg[1]) * SNAP_PCT / 100 :
			Math.min(pg[2] - pg[0], pg[3] - pg[1]) * SNAP_PCT / 100);
	var tgSZ = (TARGET == "margins") ?
		[ tg[0] + snapDist, tg[1] + snapDist, tg[2] - snapDist, tg[3] - snapDist ] :
		[ pg[0] + snapDist, pg[1] + snapDist, pg[2] - snapDist, pg[3] - snapDist ];
	var saSZ = (sa != undefined) ?
		[ sa[0] + snapDist, sa[1] + snapDist, sa[2] - snapDist, sa[3] - snapDist ] :
		[ pg[0] + snapDist, pg[1] + snapDist, pg[2] - snapDist, pg[3] - snapDist ];

	// Fit: HW (dimensions are predefined, so skip the nasty stuff)
	if (obj.label == "HW") {
		var hwRef = (TARGET == "margins") ? tg : pg;
		if (sa != undefined) { hwRef = sa; if (TARGET == "margins") tg = sa }
		if (obj.constructor.name == "TextFrame") { // Adjust inset for text frames
			obj.textFramePreferences.insetSpacing = [ 0, hwRef[1] - tg[1], tg[2] - hwRef[2], tg[3] - hwRef[3] ];
		}
		obj.geometricBounds = [ hwRef[2] - (hwRef[2] - hwRef[0]) * Number(HW_PCT) / 100, tg[1], tg[2], tg[3] ];
		return obj;
	}

	// Compute new bounds
	if (!FORCED_FIT) {
		// Check which obj's sides are in the safe area's snap zone
		var flg_sa = [
			(objG[0] <= saSZ[0] && objG[2] >= saSZ[0] && objG[1] <= saSZ[3] && objG[3] >= saSZ[1]),
			(objG[1] <= saSZ[1] && objG[3] >= saSZ[1] && objG[0] <= saSZ[2] && objG[2] >= saSZ[0]),
			(objG[2] >= saSZ[2] && objG[0] <= saSZ[2] && objG[1] <= saSZ[3] && objG[3] >= saSZ[1]),
			(objG[3] >= saSZ[3] && objG[1] <= saSZ[3] && objG[0] <= saSZ[2] && objG[2] >= saSZ[0])
		];
		// Check if obj is outside bounds | inside bounds but not in the target snap zone
		if (objV[2] <= tg[0] || objV[3] <= tg[1] || objV[0] >= tg[2] || objV[1] >= tg[3]) return;
		if (!(flg_sa[0] || flg_sa[1] || flg_sa[2] || flg_sa[3]) &&
			(objV[0] >= tgSZ[0] && objV[1] >= tgSZ[1] && objV[2] <= tgSZ[2] && objV[3] <= tgSZ[3])) return;
		// New target bounds --
		var fitR = [ // If larger, reduce to bounds
			objG[2] > tg[0] ? Math.max(objV[0], tg[0]) : objG[0],
			objG[3] > tg[1] ? Math.max(objV[1], tg[1]) : objG[1],
			objG[0] < tg[2] ? Math.min(objV[2], tg[2]) : objG[2],
			objG[1] < tg[3] ? Math.min(objV[3], tg[3]) : objG[3]
		];
		var fitE = [ // If smaller, expand to bounds if inside snap zones
			fitR[0] < tgSZ[0] ? tg[0] : (flg_sa[0] ? tg[0] : fitR[0]),
			fitR[1] < tgSZ[1] ? tg[1] : (flg_sa[1] ? tg[1] : fitR[1]),
			fitR[2] > tgSZ[2] ? tg[2] : (flg_sa[2] ? tg[2] : fitR[2]),
			fitR[3] > tgSZ[3] ? tg[3] : (flg_sa[3] ? tg[3] : fitR[3])
		];
		// But don't expand past child's bounds
		if (obj.pageItems.length == 1 && obj.fillColor.name == "None") {
			var objC = obj.pageItems[0].visibleBounds;
			fitE = [
				objC[0] > tg[0] ? objC[0] : fitE[0],
				objC[1] > tg[1] ? objC[1] : fitE[1],
				objC[2] < tg[2] ? objC[2] : fitE[2],
				objC[3] < tg[3] ? objC[3] : fitE[3]
			];
		}
		if (DEBUG) DBGFrames();
	}

	// Fit --
	// Already clipped
	if ((obj.name == "<clip frame>" || obj.name == "<auto clip frame>") && obj.pageItems[0].isValid) {
		obj.geometricBounds = FORCED_FIT ? tg : fitE; return obj;
	}
	// Simple rectangles and containers
	if (obj.constructor.name == "Rectangle" &&
		(obj.pageItems.length == 0 || obj.pageItems.length == 1) &&
		(obj.strokeWeight == 0 || obj.strokeAlignment == StrokeAlignment.INSIDE_ALIGNMENT) &&
		(objRA == 0 || Math.abs(objRA) == 90 || Math.abs(objRA) == 180)) {
			obj.geometricBounds = FORCED_FIT ? tg : fitE; return obj;
	}
	// Text frames
	if (obj.constructor.name == "TextFrame" &&
		(objRA == 0 || Math.abs(objRA) == 90 || Math.abs(objRA) == 180)) {
			obj.geometricBounds = FORCED_FIT ? tg : fitR; return obj;
	}
	// Orthogonal lines
	if (obj.constructor.name == "GraphicLine" &&
		(objG[0] == objG[2]) || (objG[1] == objG[3])) {
		// ***TODO***
		return obj;
	}
	// Groups
	if (obj.constructor.name == "Group") return Clip(obj, FORCED_FIT ? tg : fitR);
	// Other cases
	return Clip(obj, FORCED_FIT ? tg : fitE);

	function Clip(obj, fit) {
		if (objV[0] >= tg[0] && objV[1] >= tg[1] && objV[2] <= tg[2] && objV[3] <= tg[3]) return obj;
		var frame = doc.rectangles.add(
			obj.itemLayer, LocationOptions.AFTER, obj,
			{ name: "<clip frame>", label: obj.label,
			fillColor: "None", strokeColor: "None",
			geometricBounds: fit });
		frame.sendToBack(obj);
		app.select(obj); app.cut(); app.select(frame); app.pasteInto();
		return frame;
	}

	function DBGFrames() {
		var layer = doc.layers.item(".debug");
		if (!layer.isValid) {
			doc.layers.add({ name: ".debug", layerColor: UIColors.BLACK })
			.move(LocationOptions.AT_END);
		} else {
			var item, items = page.parent.pageItems.everyItem().getElements();
			while (item = items.shift()) if (item.label == "debug") item.remove();
		}
		// debugFrame("Black", false, fitE);
		// debugFrame("Black", false, fitR);
		objC && debugFrame("Yellow", false, objC);
		debugFrame("Black", false, tg);
		debugFrame("Cyan", true, tgSZ);
		debugFrame("Magenta", true, saSZ);
		debugFrame("Cyan", false, Bounds(page, "page", "margins"));

		function debugFrame(color, /*bool*/SZ, bounds) {
			var frame = page.parent.rectangles.add(layer,
				{ label: "debug", geometricBounds: bounds, contentType: ContentType.UNASSIGNED,
				fillColor: "None", strokeColor: color, strokeWeight: SZ ? snapDist : "2 pt",
				strokeAlignment: SZ ? StrokeAlignment.OUTSIDE_ALIGNMENT : StrokeAlignment.INSIDE_ALIGNMENT,
				strokeType: SZ ? "$ID/Solid" : "$ID/Canned Dashed 3x2" });
			frame.transparencySettings.blendingSettings.opacity = SZ ? 25 : 100;
		}
	}
}

} // End main()
