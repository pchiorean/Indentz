/**
 * Reads a TSV (tab-separated-values) file, returning an object containing found records and errors.
 * Blank lines and those prefixed with `#` are ignored. A line ending in `\` continues on the next line.
 * Includes records from `@path/to/include.txt` or `@default` data file (see `getDataFile()`).
 * @version 2.1 (2021-10-10)
 * @author Paul Chiorean <jpeg@basement.ro>
 * @license MIT
 * @param {File} dataFile - A tab-separated-values file (object).
 * @param {boolean} flgR - Internal flag for recursive calls (`@include`).
 * @returns {{records: array, errors: { info: array, warn: array, fail: array }}}
 * @example
 * // @include 'GetDataFile.jsxinc';
 * // @include 'Report.jsxinc';
 * var file, data;
 * if (!(file = getDataFile('data.txt'))) { alert('No data file found.'); exit(); }
 * data = parseDataFile(file);
 * if (data.errors.fail.length > 0) { report(data.errors.fail, 'Errors'); exit(); }
 * if (data.records.length === 0) exit();
 */
function parseDataFile(dataFile, flgR) {
	var infoLine, previousLine, include, includeFile;
	var buffer = [];
	var records = [];
	var errors = { info: [], warn: [], fail: [] };
	var flgHeader = false;
	var line = 0;
	dataFile.open('r');
	while (!dataFile.eof) {
		line++;
		infoLine = (previousLine ? previousLine.slice(0,-1) : '') + dataFile.readln();
		if (infoLine.slice(-1) === '\\') { previousLine = infoLine; continue; } else { previousLine = ''; }
		if (infoLine.replace(/^\s+|\s+$/g, '') === '') continue; // Ignore blank lines
		if (infoLine.slice(0,1) === '\u0023') continue;          // Ignore lines prefixed with '#'
		infoLine = infoLine.split(/ *\t */);
		if (!flgHeader) { flgHeader = true; continue; } // Header
		// '@include'
		if (infoLine[0].slice(0,1) === '\u0040') { // '@'
			include = infoLine[0].slice(1).replace(/^\s+|\s+$/g, '').replace(/^['"]+|['"]+$/g, '');
			includeFile = /^default(s?)$/i.test(include) ?                      // '@default' ?
				getDataFile(decodeURI(dataFile.name).replace(/^_/, ''), true) : // Include default data file :
				File(include);                                                  // Include 'path/to/file.txt'
			if (includeFile && includeFile.exists) {
				if (includeFile.fullName === dataFile.fullName) continue;       // Skip self
				buffer = parseDataFile(includeFile, true);
				records = records.concat(buffer.records);
				errors = {
					info: errors.info.concat(buffer.errors.info),
					warn: errors.warn.concat(buffer.errors.warn),
					fail: errors.fail.concat(buffer.errors.fail)
				};
			}
		} else { validateRecord(); }
	}
	dataFile.close(); infoLine = '';
	return { records: records, errors: { info: errors.info, warn: errors.warn, fail: errors.fail } };

	function validateRecord() {
		if (!infoLine[0]) errors.fail.push((flgR ? decodeURI(dataFile.name) + ':' : 'Line ') + line + ': Some error');
		// ...
		if (errors.fail.length === 0) {
			records.push({
				key1: infoLine[0]
				// ...
			});
		}
	}
}
