/**
 * Reads a TSV (tab-separated-values) file, returning an object containing found records and errors.
 * Blank lines and those prefixed with `#` are ignored. A line ending in `\` continues on the next line.
 * Include records from another file with `@path/to/include.txt` or the `@default` data file.
 * @version 21.10.11
 * @author Paul Chiorean <jpeg@basement.ro>
 * @license MIT
 * @param {File} dataFile - A tab-separated-values file (object).
 * @param {boolean} flgR - Internal flag for recursive calls (`@include`).
 * @returns {{records: array, errors: { info: array, warn: array, fail: array }}}
 */
function parseDataFile(dataFile, flgR) {
	var record, part, include, includeFile;
	var records = [];
	var errors = { info: [], warn: [], fail: [] };
	var tmpData = [];
	var isHeaderFound = false;
	var line = 0;
	dataFile.open('r');
	while (!dataFile.eof) {
		line++;
		record = (part ? part.slice(0,-1) : '') + dataFile.readln();
		if (record.slice(-1) === '\\') { part = record; continue; } else { part = ''; } // '\': Line continues
		if (record.replace(/^\s+|\s+$/g, '') === '') continue; // Blank line, skip
		if (record.slice(0,1) === '\u0023') continue;          // '#': Comment line, skip
		if (record.slice(0,1) === '\u0040') {                  // '@': Include directive, parse file
			include = record.slice(1).replace(/^\s+|\s+$/g, '').replace(/^['"]+|['"]+$/g, '');
			includeFile = /^default(s?)$/i.test(include) ?
				getDataFile(decodeURI(dataFile.name).replace(/^_/, ''), true) : // Default data file
				File(include); // 'path/to/file.txt'
			if (includeFile && includeFile.exists) {
				if (includeFile.fullName === dataFile.fullName) continue; // Skip self
				tmpData = parseDataFile(includeFile, true);
				records = records.concat(tmpData.records);
				errors = {
					info: errors.info.concat(tmpData.errors.info),
					warn: errors.warn.concat(tmpData.errors.warn),
					fail: errors.fail.concat(tmpData.errors.fail)
				};
			} else {
				errors.warn.push((flgR ? decodeURI(dataFile.name) + ':' : 'Line ') + line +
				': \'' + include + '\' not found.');
			}
			continue;
		}
		if (!isHeaderFound) { isHeaderFound = true; continue; } // Header line, skip
		record = record.split(/ *\t */);
		checkRecord();
	}
	dataFile.close(); record = '';
	return { records: records, errors: { info: errors.info, warn: errors.warn, fail: errors.fail } };

	function checkRecord() {
		var tmpErrors = { info: [], warn: [], fail: [] };
		if (!record[0]) tmpErrors.warn.push((flgR ? decodeURI(dataFile.name) + ':' : 'Line ') + line + ': Some error');
		// ...
		if (tmpErrors.warn.length === 0 && tmpErrors.fail.length === 0) {
			records.push({
				key1: record[0] // || someDefaultValue
				// ...
			});
		}
		errors = {
			info: errors.info.concat(tmpErrors.info),
			warn: errors.warn.concat(tmpErrors.warn),
			fail: errors.fail.concat(tmpErrors.fail)
		};
	}
}
