/**
 * Appends a debugging line to a file saved on the desktop with the name of the running script
 * (e.g. `active-script.log`). If no arguments are given, it just appends an empty line.
 * @version 1.1 (2021-10-16)
 * @author Paul Chiorean <jpeg@basement.ro>
 * @license MIT
 * @param {string} [type] - A single character string: <ul> <li>`+` appends `MESSAGE` to the previous line;</li>
 * <li>`I`, `W`, `E`, `F`, `M`, `N`, `T` or space outputs `[INFO]`, `[WARN]`, `[ERR]`, `[FAIL]`, `[MARK]`, `[NOTE]`,
 * `[TODO]` or spacer.</li> </ul> (Optional.)
 * @param {string} [context] - A string enclosed in `<` `>`. (Optional.)
 * @param {string} message - A comma-separated list of message parts (`part1`, `part2`, `part3`, ...).
 * @example
 * dbg('i', '<ParseIF>', 'Open data file: \'' + decodeURI(dataFile.name) + '\'');
 * // <snip>
 * if (errors.length === 0) dbg('+', 'Records: ' + data.length, 'Layouts: ' + layouts.length);
 * // Output:
 * // 2021-07-31 18:48:02.609 [INFO] ParseIF :: Open data file: 'test.txt' | Records: 14 | Layouts: 0
 * // └─────────────────────┘ └────┘ └────────┘ └────────────────────────┘   └─────────┘   └────────┘
 * //        typestamp         type   context         message part1             part2         part3
 */
function dbg(/* ?type, ?context, message */) {
	var script = (function () { try { return app.activeScript; } catch (e) { return new File(e.fileName); } }());
	var debugFile = File(Folder.desktop + '/' + script.name.slice(0, script.name.lastIndexOf('.')) + '.log');
	var t = new Date();
	var now = t.getFullYear()       + '-' +
		pad(t.getMonth() + 1,    2, '0') + '-' +
		pad(t.getDate(),         2, '0') + ' ' +
		pad(t.getHours(),        2, '0') + ':' +
		pad(t.getMinutes(),      2, '0') + ':' +
		pad(t.getSeconds(),      2, '0') + '.' +
		pad(t.getMilliseconds(), 3, '0') + ' ';

	debugFile.open('a');
	debugFile.encoding = 'UTF-8';
	debugFile.write(parseArgs([].slice.call(arguments)));
	debugFile.close();

	function parseArgs(args) {
		var type = '';
		var context = '';
		var separator = ' | ';

		if (args.length === 0) return (debugFile.length === 0 ? (now + 'Log created') : '\n');

		switch (args[0].toString().toLowerCase()) {
			case '+': return (args.shift(), separator + args.join(separator).replace(/\r|\n/g, '\u00B6'));
			case 'i': type = '[INFO] '; break;
			case 'w': type = '[WARN] '; break;
			case 'e': type = ' [ERR] '; break;
			case 'f': type = '[FAIL] '; break;
			case 'm': type = '[MARK] '; break;
			case 'n': type = '[NOTE] '; break;
			case 't': type = '[TODO] '; break;
			case ' ': type = '       '; break;
			case '' : type = '       '; break;
		}
		if (type) args.shift();

		if (/^<.+>$/g.test(args[0])) {
			context = args[0].toString().slice(1, args[0].length - 1) + ' :: ';
			args.shift();
		}
		return ('\n' + now + type + context + args.join(separator).replace(/\r|\n/g, '\u00B6'));
	}

	function pad(string, /*number*/padLength, /*string*/padChar) {
		if (string.toString().length === padLength) return string;
		padChar = padChar || ' ';
		string = string.toString();
		while (string.length < padLength) string = padChar.toString() + string;
		return string.slice(0, padLength);
	}
}
