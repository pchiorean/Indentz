/**
 * Appends a debugging line to a file saved on the desktop with the name of the running script
 * (e.g. `active-script.log`). If no arguments are given, it just appends an empty line.
 * @version 23.9.11
 * @author Paul Chiorean <jpeg@basement.ro>
 * @license MIT
 * @param {string} message - A list of messages (`part1`, `part2`, `part3`, etc.) that will
 * be appended to the timestamp and the stack trace; you can append them to the previous line
 * using `+` as the first argument, or an empty string (``) to skip the separator. `^` or `$`
 * as the first ergument defines the start or the end of a block.
 * @example
 * log('Data file: \'' + decodeURI(dataFile.name) + '\'');
 * log('+', 'Records: ' + data.length, 'Layouts: ' + layouts.length);
 * // Output:
 * // 2021-07-31 18:48:02.609 main::parseDataFile:: Data file: 'test.tsv' | Records: 14 | Layouts: 2
 * // └─────────────────────┘ └───────────────────┘ └───────────────────┘   └─────────┘   └────────┘
 * //        typestamp                stack             message part1          part2         part3
 */
function log(/*?message list*/) {
	var script = (function () { try { return app.activeScript; } catch (e) { return new File(e.fileName); } }());
	var debugFile = File(Folder.desktop + '/' + script.name.slice(0, script.name.lastIndexOf('.')) + '.log');
	var padding = (!debugFile.exists || debugFile.length === 0) ? '' : '\n';
	var t = new Date();
	var time = t.getFullYear()           + '-' +
		pad(t.getMonth() + 1,    2, '0') + '-' +
		pad(t.getDate(),         2, '0') + ' ' +
		pad(t.getHours(),        2, '0') + ':' +
		pad(t.getMinutes(),      2, '0') + ':' +
		pad(t.getSeconds(),      2, '0') + '.' +
		pad(t.getMilliseconds(), 3, '0') + ' ';
	var folding = [ '\u250C\u2500 ', '\u2502 ', '\u2514\u2500 ' ];
	var message = '';
	var line;

	if (arguments.length === 0) line = padding;
	else if (arguments[0] == null) line = '\nFUBAR'; // [TODO]
	else line = parseArgs([].slice.call(arguments), ' | ');

	debugFile.open('a');
	debugFile.encoding = 'UTF-8';
	debugFile.lineFeed = 'Unix';
	debugFile.write(line);
	debugFile.close();

	function parseArgs(args, sep) {
		switch (args[0].toString().toLowerCase()) {
			case '': // Append to previous line (no separator)
				args.shift();
				break;
			case '+': // Append to previous line (with separator)
				args.shift();
				if (args.length > 0) message += sep;
				break;
			case '^': // Folding block start
				args.shift();
				message = padding + time + stack() + folding[0]
					+ (args.length === 0 ? $.stack.split(/[\n]/).slice(-3, -2) : '');
				break;
			case '$': // Folding block end
				args.shift();
				message = padding + time + stack() + folding[2]
					+ (args.length === 0 ? $.stack.split(/[\n]/).slice(-3, -2) : '');
				break;
			default: // Standard message
				message = padding + time + stack() + folding[1];
		}

		return message + args.join(sep).replace(/\r|\n/g, '\u00B6');

		function stack() {
			var arr = $.stack.split(/[\n]/);
			arr = arr.slice(1, -3);
			return arr.length > 0 ?
				arr.join('::').replace(/\(.*?\)/g, '').replace('anonymous', 'anon') + ':: ' :
				'';
		}
	}

	function pad(string, /*number*/padLength, /*string*/padChar) {
		if (string.toString().length === padLength) return string;
		padChar = padChar || ' ';
		string = string.toString();
		while (string.length < padLength) string = padChar.toString() + string;
		return string.slice(0, padLength);
	}
}
